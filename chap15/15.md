### longest common subsequence problem ⭐
Subproblem for multiple sequence inputs $\Rightarrow$ product of multiple subproblem spaces

    Given sequences A,B, find longest sequence L that's subsequence of both A and B. 

Define subproblem $L(i,j)$: Find LCS between suffixes $A[i:]$ and $B[j:]$.

$$

\begin{cases}
L(i,j) = 1+L(i+1,j+1) \quad\text{if A[i]==B[j]}\\
L(i,j) = \max(L(i+1,j),L(i,j+1)) \quad\text{otherwise}\\
L(|A|,j) = 0 = L(i,|B|)
\end{cases}
$$

If $A[i]!=B[j]$, $A[i]$ and $B[j]$ can not both be in LCS between $A[i:]$ and $B[j:]$. Then there are two possible cases to consider: $A[i]$ not in LCS or $B[j]$ not in LCS.

$T=\Theta(|A||B|)$.

_Further memory reduction can be applied._

### longest increasing subsequence problem ⭐

    Given sequences A, find longest [strictly] increasing subsequence.

_If elements are restricted to 26 English letters, problem can be solved in linear time._

Define subproblem $L(i)$: find LIS of suffix $A[i:]$ that starts with $A[i]$.

_**Subproblem expansion** let us add more constraints to subproblems, similar idea as Layered Graph_

$$
\begin{cases}
L(i) = 1 + \max\{L(j)|i<j\le n,A[i]<A[j]\}\cup \{0\}\\
L(|A|) = 0
\end{cases}
$$

$LIS(A)=\max L(i)$.

$T=\Theta(|A|^2)$.

**What other question can we ask about subproblem features?**
Assume at some point $a_1,a_2,...,a_m$ has the smallest ending element among all length-$m$ increasing subsequence and $b_1,b_2,...,b_n$ has the smallest ending element among all length-$n$ increasing subsequence. $m > n \Leftrightarrow a_m > b_n$.

**Proof:**
$\Rightarrow$ If $m>n$ and $a_m\le b_n$, then subsequence $a_1,a_2,...,a_n$ will be a length-$n$ increasing subsequence with smaller ending element $a_n$. Contradicts with assumption. By proof of contradiction, if $m>n$ then $a_m> b_n$.

$\Leftarrow$ Similarly if $a_m>b_n$ and $m<n$, then subsequence $b_1,b_2,...,b_m$ will be a length-$m$ increasing subsequence with smaller ending element $b_m$, By proof of contradiction, if  $a_m> b_n$ then $m>n$.

**LIS Recursive Algorithm with a little Augmentation:**
At the time calculating $LIS(i)$, we already know $LIS(i+1),...,LIS(|A|)$. Keep record of largest starting elements for LIS of each length, which is in sorted order. Binary search for longest LIS that has starting element bigger than $A[i]$. Add one to that size.

$T=\Theta(|A|\log |A|)$.

