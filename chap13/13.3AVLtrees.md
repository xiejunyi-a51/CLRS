c. Firstly, insert z in T according to BST rule. Secondly, go up against z's ancestors until first unbalanced node. Rebalance the unbalanced node if found one by making one or two rotation operations and then quit tracing up. While climbing up the tree, recalculate the height of each. If no unbalanced node found, we go up all the way to T.root.

d. Let us denote the lowest unbalanced ancestor x, and the subtree rooted at it $T_x$. It's unbalance is caused by the height of one of its subtree $T_y$ containing z increases by one. And consequently, $T_x$.height increases by one. $T_x$ is originally within balance, that means after inserting x, skew of $T_y$ is either 1 or -1, not 0. Otherwise $T_y$.height won't change and $T_x$ won't be out of balance. Being either 1 or -1 of $T_y$'s skew, after rebalance, $T_x$.height decreases by one and remain its original value before insertion. Therefore no further ancestors of x can be affected and their heights remain untouched. In conclusion an insertion on AVL tree takes at most two rotations and $\text{O}{(\log{n})}$ time.

An deletion operation on the other hand, may take up to $\text{O}{(\log{n})}$ rotations in the worst case. Consider unbalanced ancestors, both deleting one node and rebalance can only make their subtrees containing deleted node less high. Fibbonacci tree (minimum size AVL tree given height) is one example.

RB-trees have less restrictive rules and therefore allow constant number of rotations to fix up both insertion and deletion. 